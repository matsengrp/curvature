\documentclass{amsart}

\usepackage{amsmath}
\usepackage{ifthen}
\usepackage{todonotes}

\newtheorem{theorem}{Theorem}[section]
\newtheorem{lemma}[theorem]{Lemma}
\newtheorem{corollary}[theorem]{Corollary}
\newtheorem{proposition}[theorem]{Proposition}
\newtheorem{example}[theorem]{Example}
\newtheorem{definition}[theorem]{Definition}

\newcommand{\RR}{\mathbb R}
\newcommand{\TT}{\mathcal T}

%---[ Parenthesization ]--------------------------------------------------------

\newcommand{\newparentheses}[3]{%
  \expandafter\newcommand\csname #1\endcsname[1]{#2##1#3}%
  \expandafter\newcommand\csname #1L\endcsname[1]{\bigl#2##1\bigr#3}%
  \expandafter\newcommand\csname #1XL\endcsname[1]{\Bigl#2##1\Bigr#3}%
  \expandafter\newcommand\csname #1V\endcsname[1]{\left#2##1\right#3}}

\newparentheses{parens}{(}{)}
\newparentheses{floor}{\lfloor}{\rfloor}
\newparentheses{ceil}{\lceil}{\rceil}
\newparentheses{abs}{|}{|}
\newparentheses{set}{\{}{\}}
\newparentheses{size}{|}{|}

%---[ Attributes ]--------------------------------------------------------------

\makeatletter
\newcommand{\onenewattribute}[3]{%
  \@ifundefined{#1}{\let\@@def\newcommand}{\let\@@def\renewcommand}%
  \expandafter\@@def\csname #1\endcsname[2][]{%
    \ifthenelse{\equal{##1}{}}%
    {#2\csname #3\endcsname{##2}}%
    {#2_{##1}\csname #3\endcsname{##2}}}}
\newcommand{\newattribute}[2]{%
  \onenewattribute{#1}{#2}{parens}%
  \onenewattribute{#1L}{#2}{parensL}%
  \onenewattribute{#1XL}{#2}{parensXL}%
  \onenewattribute{#1V}{#2}{parensV}}
\makeatother

%---[ Asymptotic notation ]-----------------------------------------------------

\newattribute{OhOf}{\mathrm{O}}
\newattribute{ThetaOf}{\Theta}
\newattribute{OmegaOf}{\Omega}
\newattribute{ohOf}{\mathrm{o}}
\newattribute{omegaOf}{\omega}
%\newattribute{min}{\text{min}}
%\newattribute{max}{\text{max}}

%---[ Distance measures, invocations, etc ]-------------------------------------
\newattribute{dspr}{d_{\mathrm{SPR}}}


\begin{document}
\title{Ricci curvature of the phylogenetic subtree-prune-regraft graph}
\author[Whidden]{Christopher Whidden}
\author[Matsen]{Frederick Matsen}
\address{}
\thanks{}

\date{\today}

\begin{abstract}
\end{abstract}

\maketitle

% % Make a todo table of contents.
% \makeatletter
% \providecommand\@dotsep{5}
% \makeatother
% \listoftodos\relax


\section{Introduction}


\section{$k$-tubes}

The curvature with respect to two topologies, $T_1$ and $T_2$, is primarily determined by a subset of the SPR graph in the localized neighborhood of these topologies.
We first require some notation to define these subsets.
Let $\TT$ be the full set of topologies with a given number of leaves.
Denote the set of trees with SPR distance at most $k$ from a given tree $T$ by $N_k(T)$.
These trees are the $k$-neighbors of $T$.
That is, $$ N_k(T) = \set{t \in \TT \mid \dspr{T, t} \le k} .$$

We now define the $k$-tube of two trees $T_1$ and $T_2$ to be the union of their $k$-neighbors and \emph{every tree on a shortest path between a $k$-neighbor of $T_1$ and a $k$-neighbor of $T_2$}.
More formally, the $k$-tube for $T_1$ and $T_2$ is:
\[ \set{t \in \TT \mid \dspr{t, t_1} + \dspr{t, t_2} = \dspr{t_1, t_2},\ \exists_{t_1 \in N_k(T_1)},\ \exists_{t_2 \in N_k(T_2)} } .\]
We call $T_1$ and $T_2$ the centers of the $k$-tube.
The distance between $k$-neighbors of different central trees is bounded by the maximum distance from each $k$-neighbor to its respective center and the maximum distance between the centers:

\begin{lemma}
	\label{lem:neighbor_distance}
	$\dspr{t_1, t_2} \le \dspr{T_1, T_2} + 2k,\ \forall_{t_1 \in N_k(T_1)},\ \forall_{t_2 \in N_k(T_2)} } .$
\end{lemma}

To efficiently compute a $k$-tube, we first bound the maximum distance from members of the $k$-tube to the closest central tree.
\begin{lemma}
	\label{lem:k_tube_distance}
	Any tree $t$ of the $k$-tube of two trees $T_1$ and $T_2$ satisfies:
	\[ \min\left({\dspr{t, T_1}, \dspr{t, T_2}}\right) \le \floor{\dspr{T_1, T_2}/2} + 2k .\]
\end{lemma}
\begin{proof}
Without loss of generality, assume that $t$ is on a shortest path between two trees $t_1 \in N_k(T_1)$ and $t_2 \in N_k(T_2)$, and is either closer to $t_1$ than $t_2$ or equidistant from both.
By Lemma~\ref{lem:neighbor_distance} there is a path of length at most $\dspr{T_1, T_2} + 2k$ between $t_1$ and $t_2$.
Then $\dspr{t, t_1} \le \floor{(\dspr{T_1, T_2} + 2k) / 2}$.  

Along with the fact that $\dspr{T_1, t_1} \le k$, we have that
\begin{align*}
\dspr{t, T_1} &\le \dspr{t, t_1} + \dspr{t_1, T_1} \\
&\le \floor{(\dspr{T_1, T_2} + 2k) / 2} + k \\
&\le \floor{\dspr{T_1, T_2} / 2} + 2k.
\end{align*}

\end{proof}
We can thus restrict our search for members of the $k$-tube to topologies of distance at most $\floor{\dspr{T_1, T_2}/2} + 2k$ from the central trees.
We call this set of trees $k$-tube candidates.
Note that there are $\OhOf{n^{2(\floor{\dspr{T_1, T_2}/2} + 2k)}}$ $k$-tube candidates.
We identify these candidates by iterating over increasingly large $k$-neighbourhoods of $T_1$ and $T_2$, and removing duplicate topologies through hashing.  \todo{We might be able to do better by using ``edge protection'' to avoid duplicates. I need to check how accurately neighbourhood sizes follow the naive $\OhOf(n^{2k})$ bound.}

In the second part of our procedure for computing a $k$-tube, we identify $k$-tube candidates that are not on the shortest path between two $k$-neighbors of the central trees.
We first compute shortest path lengths from each member of $N_k(T_1)$ to each $k$-tube candidate using breadth-first search (BFS).
For each BFS traversal tree, we backtrack from members of $N_k(T_2)$, identifying topologies in the $k$-tube.
We can use unique tree indices here, rather than hashing, to avoid duplicates. 
The size of $N_k(T_1)$ is $\OhOf{n^{2k}}$, so this takes
$\OhOf( n^{2k} M)$ time, where $M$ is the number of edges between $k$-tube candidates, that is, at most the square of the number of $k$-tube candidates. \todo{We could probably do something smarter by starting from trees that are 0, 1, etc SPRs from $T_1$.}

This procedure identifies exactly the trees in the $k$-tube, so we have the following lemma:
\begin{lemma}
	\label{lem:k_tube_correctness}
	This procedure correctly identifies the $k$-tube.
\end{lemma}
\begin{proof}
	First, suppose that this procedure identifies a tree $x$ that is not in the $k$-tube.
	Assume, without loss of generality, that the BFS tree $B$ from tree $t_1 \in N_k(T_1)$ transitioned from $x$ to a $k$-tube tree $t$.
	Moreover, there must be a path in $B$ from $t$ to a tree $t_2 \in N_k(T_2)$ such that $t$ is on a shortest path from $t_1$ to $t_2$.
	Then, by the properties of BFS, $x$ is on this shortest path and belongs in the $k$-tube.

	Now, suppose that this procedure does not identify a tree $x$ that belongs in the $k$-tube.
	$x$ must be on a shortest path between some trees $t_1 \in N_k(T_1)$ and $t_2 \in N_k(T_2)$.
	Then, by the properties of BFS, $x$ would have been on the path from $t_1$ to $t_2$ in the $t_1$ BFS tree.
\end{proof}

% \bibliographystyle{plain}
% \bibliography{curvature}
\end{document}

